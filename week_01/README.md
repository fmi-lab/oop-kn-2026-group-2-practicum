# 1: Преговор, template, function pointer

# Template (Шаблони)

## 0) Print

Напишете шаблон на функция, която приема масив от елементи от произволен тип и принтира елементите му на стандартния изход.

## 1) сума

Напишете шаблон на функция, която приема масив от елементи от произволен тип и връща тяхната сума като стойност от същия тип. 
Какво става ако типът, който подаваме на функцията няма оператор '+'.

## 2) максимален елемент

Напишете шаблон на функция, която намира най-големия елемент в масив от произволен тип.

## 3) брой положителни елементи

Напишете шаблон на функция, която приема масив от произволен тип и връща броя елементи, които са не по-малки от `0`.

## 4) елементи над граница

Напишете шаблон на функция, която приема масив от произволен тип `arr` и още един елемент `k`. Функцията да връща динамично заделен масив, в който са копирани елементите на `arr`, които са по-големи от `k`. Броят на елементите във върнатия масив да се връща чрез референция, подадена като аргумент.
```cpp
	float arr3[] = {-2, 1, 3, -1, 3, -10};
	size_t filteredSize;
	float *filtered = filterMoreThan(arr3, 6, -1.f, filteredSize);
	print(filtered, filteredSize);
```

# Указатели към функции

## 5) 
Напишете функция `loop`, която приема параметри функция без параметри, както и цяло положително число `n` и изпълнява функцията `n` на брой пъти.
## 6) 
Напишете функция `repeat`, която приема параметри целочислена функция с един целочислен параметър `f(x)` и две цели числа: `x0` и `n`. Функцията да връща резултатът от `f(f(...f(x0)...)` - `f` приложено `n` пъти върху `x0`.

## 7) 
Напишете функция `sort`, която приема масив от цели числа, както и булева функция с два целочислени параметъра. Функцията да сортира масива, използвайки подадената функция като заместител на релацията '<' при сортирането. т.е. `f(a, b) <=> a < b`.

## 8)
Напишете функция `applyInOrder`, която приема масив от функции $Т \rightarrow Т$, масив от положителни цели числа и елемент от тип `Т`. Функцията да прилага функциите от масива върху елемента в реда, описан в масива от цели числа, и накрая да връща получения резултат. 

### Пример:
```cpp
int inc(int x) { return x + 1; }
int mul2(int x) { return x * 2; }
int dec(int x) { return x - 1; }
int main() {
    int (*funcs[])(int) = {inc, mul2, dec};
    size_t order1[] = {2, 0, 1};
    size_t order2[] = {0, 1, 2};
    std::cout << applyInOrder<int>(funcs, order1, 3) << std::endl; // ((3 - 1) + 1) * 2 = 6
    std::cout << applyInOrder<int>(funcs, order2, 3) << std::endl; // ((3 + 1) * 2) - 1 = 7
}
```

# Бонус задача

Напишете функция `filter`, която приема масив от произволен тип, както и булева функция с единствен параметър от същия тип `f(x)`. Функцията да връща указател към динамично заделен масив, в който се съдържат само елементите на масива, за които `f(x)` е 'истина'. Размерът на върнатия масив да се връща чрез презаписване на стойността на аргумента `retSize`.
```cpp
... filter(... *arr, size_t size, ... f, size_t &retSize)
```

